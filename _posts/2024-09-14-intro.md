---
layout: post
title: "<em>LMCache:</em> Faster and Cheaper LLMs with a CDN of Knowledge"
thumbnail-img: /assets/img/lmcache-logo-small.png
share-img: /assets/img/lmcache-logo-small.png
author: LMCache Team
---

## **TL;DR:** _Turbocharging vLLM with 7x faster access to 100x more KV caches using <img src="/assets/img/lmcache-logo-small.png" alt="Icon" style="width:140px; vertical-align:middle;">_

LLMs have become ubiquitous across industries, but when using them with long documents, it takes forever for the first token to come out. Here comes LMCache, a novel system developed in UChicago that allows the first token to come out 3-10x faster by efficiently managing long documents (and other sources of knowledge) for you.

<div align="center">
<img src="/assets/img/lmcache-diagram.png" alt="Icon" style="width:700px; vertical-align:middle;">
</div>

## What is LMCache?

No matter how smart LLMs become, it is always slow and costly for them to read external texts, videos, etc. LMCache reduces this cost by letting LLMs _**read each text only once**_. This is because most data are _repetitively read_, such as popular books, chat history, and news documents. 
In short, 20% of knowledge is used 80% of the time, i.e., Pareto's Rule. 

By storing the KV caches (the LLM-usable representation) of _**all**_ reusable texts, LMCache can reuse the KV caches of _**any**_ reused text (not necessarily the prefix) in _**any**_ serving engine instance. 
Developed at UChicago, this solution is already gaining significant interest from industry partners.

By combining LMCache with vLLM, LMCache reduces time to the first token (TTFT) by 3-10x and saves the GPU cycle reduction in many LLM use cases, including multi-round QA and RAG.

<div align="center">
<img src="/assets/img/lmcache-gain-short.png" alt="Icon" style="width:700px; vertical-align:middle;">
</div>


## The Secret Sauces

This table contrasts vLLM with and without LMCache:

<div align="center">
<img src="/assets/img/lmcache-contrast.png" alt="Icon" style="width:700px; vertical-align:middle;">
</div>

At its core, LMCache uses two core techniques.

- **CacheGen** [SIGCOMM'24](https://arxiv.org/abs/2310.07240) efficiently encodes KV caches into bitstreams and stores them on disks.
This allows unlimited amount of KV caches to be stored on cheap disks and be shared across multiple vLLM instances. 
It is in contrast with vLLM which stores KV caches only in one LLM instance's internal GPU and CPU memory.
This capability is pressingly needed in multiple-round chat apps that use many vLLM instances to serve many users. 


- **CacheBlend** [EuroSys'25](https://arxiv.org/abs/2405.16444) blends KV caches with minimum computation to preserve cross-attention. 
This allows multiple KV caches to be composed together to dynamically form a new KV cache.
In contrast, vLLM only reuses the KV cache of the input prefix.
This is particularly useful for RAG applications where multiple reused texts constitute the LLM input.

<!--- CacheGen [SIGCOMM'24](https://arxiv.org/abs/2310.07240): A KV-cache compression system that encodes KV caches into compact bitstreams.-->
<!--- CacheBlend [EuroSys'25](https://arxiv.org/abs/2405.16444): A KV-cache blending system that dynamically composes new KV caches from smaller ones.-->


## Get Started with LMCache

We provide a docker-based quickstart demo that lets you start a serving engine (vLLM) with LMCache and then query the serving engine with a long context.

To begin with, you need to have a GPU server with the [docker environment](https://docs.docker.com/engine/install/) plus [nvidia-runtime](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html) installed. 


To start the serving engine
```bash
git clone https://github.com/LMCache/LMCache && cd LMCache/examples && bash quickstart.sh
```

The serving engine is ready after you see the following lines in the log:
<div align="center">
<img src="/assets/img/lmcache-install-info.png" alt="Icon" style="width:700px; vertical-align:middle;">
</div>

Now, run the following command to start the query front end:
```bash
pip install openai streamlit
streamlit run examples/quickstart-frontend.py
```

You should be able to access the frontend from your browser at `http://<your server's IP>:8501`

The first query has a long TTFT because the server needs to prefill the long context. But once the first query finishes, the TTFT of all future queries will be much lower as LMCache shares the KV cache to vLLM which can then skip the prefill of the long context.

We also provide multiple demos at [ðŸ”—LMCache-demos repo](https://github.com/LMCache/demo). The demos cover the following use cases:
- Share KV caches across multiple serving engines [(ðŸ”—link)](https://github.com/LMCache/demo/tree/master/demo2-multi-node-sharing)
- Loading non-prefix KV caches for RAG [(ðŸ”—link)](https://github.com/LMCache/demo/tree/master/demo3-KV-blending)

